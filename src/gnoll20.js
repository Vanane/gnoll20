function createElementFromHTML(html) { var template = document.createElement('template'); template.innerHTML = html; return template.content.children[0]; } Math.clamp = (v, min, max) => { return v > max ? max : v < min ? min : v; };class ComponentManager { /** @type {ComponentManager} */ static instance = null; /** @type {MouseEvent} */ mouse; /** @type {MouseEvent} */ prevMouse; /** @type {Blank} */ blank; constructor() { if(ComponentManager.instance != null) throw Error("Already instanciated"); ComponentManager.instance = this; this.components = {}; this.enableMousePosition(); this.blank = Blank.instantiate(document.children[0], "_blank").setAttributes({ name:"_blank" }); } enableMousePosition() { document.ondragover = (e) => { /* Met à jour la variable this.mouse lorsqu'on drag un onglet */ this.prevMouse = this.mouse; this.mouse = e; }; document.onmousemove = (e) => { /* Met à jour la variable this.mouse lorsqu'on passe la souris par-dessus n'improte quel élément. OnDragOver annule cet event, c'est pourquoi nous utilisons les deux events. */ this.prevMouse = this.mouse; this.mouse = e; }; } addComponent(c) { if(c.name) this.components[c.name] = c; else throw Error("Component lacks name"); } }/** * Encapsulation de la création dynamique d'élément */ class Component { /** @type {string} */ static baseHTML = ``; static axes = {top:"top", left:"left", bottom:"bottom", right:"right"}; /** @type {HTMLElement} */ parent; /** @type {HTMLElement} */ dom; /** @type {string} */ name; /** @type {Boolean} */ restrictDrag; static instantiate(parentDom, name) { return new Component(parentDom, name); } static fromRaw(parentDom, name, html) { var c = new Component(parentDom, name, false); c.html = html; return c.write(); } constructor(parentDom, name, write=true) { this.parent = parentDom; this.name = name; this.html = this.constructor.baseHTML; if(write) this.write(); ComponentManager.instance.addComponent(this); } setAttributes(attrs) { for(var i in attrs) { this.dom.setAttribute(i, attrs[i]); } return this; } setStyle(styleAttrs) { for(var i in styleAttrs) { this.dom.style[i] = styleAttrs[i]; } return this; } makeDraggable(bool=true) { if(bool) { this.dom.setAttribute('draggable', 'true'); this.dom.classList.add('draggable'); this.dom.ondragstart = this.onDragStart; this.dom.ondrag = this.onDrag; } else { this.dom.removeAttribute('draggable'); this.dom.classList.remove('draggable'); delete this.dom.ondragstart; delete this.dom.ondrag; } return this; } afterDrag(func=null) { this.dom.ondragend = func; } restrictDragToParent(bool=true) { this.restrictDrag = bool; return this; } makeClickable(bool=true, func=null) { if(bool) this.dom.onclick = func; else delete this.dom.onclick; return this; } /** * * @param {Object} from Quels côtés sont redimensionnables : bottom, top, left, right */ makeResizable(from) { if(from[Component.axes.top]) { Resizer.instantiate(this.dom, `${this.name}-resizer`, Component.axes.top); } if(from[Component.axes.left]) { Resizer.instantiate(this.dom, `${this.name}-resizer`, Component.axes.left); } if(from[Component.axes.bottom]) { Resizer.instantiate(this.dom, `${this.name}-resizer`, Component.axes.bottom); } if(from[Component.axes.right]) { Resizer.instantiate(this.dom, `${this.name}-resizer`, Component.axes.right); } } setTags(tagsAndReplace) { for(var i in tagsAndReplace) { this.html = this.html.replaceAll(`{{${i}}}`, tagsAndReplace[i]); } return this; } write() { if(!this.html) throw Error("Empty HTML given"); var template = document.createElement('template'); template.innerHTML = this.html; this.dom = template.content.children[0]; this.dom.component = this; this.parent.appendChild(this.dom); return this; } /** Events **/ onDragStart(e) { e.dataTransfer.setDragImage(ComponentManager.instance.blank.dom, 0, 0); this.mouseOffset = { x: ComponentManager.instance.mouse.clientX - this.style.left.split('px')[0], y: ComponentManager.instance.mouse.clientY - this.style.top.split('px')[0] }; } onDrag(e) { var rect = this.getBoundingClientRect(); var parentRect = this.parentElement.getBoundingClientRect(); var x = ComponentManager.instance.mouse.clientX - this.mouseOffset.x; var y = ComponentManager.instance.mouse.clientY - this.mouseOffset.y; if(this.component.restrictDrag) { x = Math.clamp(x, parentRect.x, parentRect.x + parentRect.width - rect.width); y = Math.clamp(y, parentRect.y, parentRect.y + parentRect.height - rect.height); } this.style.left = `${x}px`; this.style.top = `${y}px`; } }class Blank extends Component { static baseHTML = `<span></span>`; static instantiate(parentDom, name, id) { return new Blank(parentDom, name); } }/** * Encapsulation de Component pour ajouter du comportement autour d'un élément */ class Layer extends Component { static baseHTML = `<canvas class='board-layer'><img class="layer-img"></img></canvas>`; /** @type {Token[]}} */ tokens; /** @type {CanvasRenderingContext2D} */ context2D; /** @type {HTMLImageElement} */ backgroundImage; static instantiate(parentDom, name, id) { return new Layer(parentDom, name) .setAttributes({name, id}); } constructor(parentDom, name) { super(parentDom, name); this.tokens = []; this.context2D = this.dom.getContext("2d"); this.backgroundImage = this.dom.getElementsByTagName("img")[0]; } setBackgroundURL(bg) { var img = this.dom.getElementsByTagName("img")[0]; img.src = bg; img.onload = () => { this.renderAll() }; return this; } /** Spécifique layer **/ addToken(t) { this.tokens[t.name] = t; this.renderAll(); return this; } removeToken(name) { delete this.tokens[name]; this.renderAll(); return this; } renderBackground() { this.context2D.drawImage(this.backgroundImage, 0, 0); } renderTokens() { for(var t in this.tokens) { this.context2D.drawImage(t.getImage(), t.position.x, t.position.y); } } renderLight() { } renderGrid() { } renderAll() { this.renderBackground(); this.renderLight(); this.renderGrid(); this.renderTokens(); } }class Token extends Component { static baseHTML = `<div class="board-token"><span class="token-title">prout</span><img class="token-img"><img></div>`; /** @type {HTMLSpanElement} */ title; /** @type {HTMLImageElement} */ image; static instantiate(parentDom, name) { return new Token(parentDom, name).makeDraggable().restrictDragToParent(); } constructor(parentDom, name) { super(parentDom, name); this.title = this.dom.getElementsByClassName("token-title")[0]; this.image = this.dom.getElementsByClassName("token-img")[0]; } setTitle(title) { this.title.innerHTML = `${title}`; return this; } setImage(url) { this.image.src = url; return this; } }class SideBar extends Component { static baseHTML = `<div class="sidebar"><span class="sidebar-title"></span><div class="sidebar-content"></div></div>`; /** @type {HTMLSpanElement} */ title; /** @type {HTMLElement} */ content; static instantiate(parentDom, name) { return new Token(parentDom, name); } constructor(parentDom, name) { super(parentDom, name); this.title = this.dom.getElementsByClassName("sidebar-title")[0]; this.content = this.dom.getElementsByClassName("sidebar-content")[0]; } setTitle(title) { this.title.innerHTML = `${title}`; return this; } setContent(content) { this.content.innerHTML = `${content}`; return this; } setWidth(width) { this.dom.style.width = `${width}px`; return this; } }class Resizer extends Component { static baseHTML = `<div class="resizer"></div>`; /** @type {HTMLElement} */ target; constructor(parentDom, name) { super(parentDom, name); this.setStyle({ zIndex:'1000', minWidth:'0px', minHeight:'0px'}); this.setAttributes({draggable:'true'}); this.dom.classList.add('resizer'); this.dom.ondragstart = this.onResizerDragStart; } static instantiate(parentDom, name, axis) { return new Resizer(parentDom, `${name}-${axis}`) .setTarget(parentDom) .setAxis(axis); } setTarget(target) { this.target = target; return this; } setAxis(axis) { this.axis = axis; this.dom.classList.add(`resizer-${this.axis}`); switch(this.axis) { case Component.axes.bottom: this.dom.ondrag = this.onResizeBottom; break; case Component.axes.top: this.dom.ondrag = this.onResizeTop; break; case Component.axes.left: this.dom.ondrag = this.onResizeLeft; break; case Component.axes.right: this.dom.ondrag = this.onResizeRight; break; } return this; } /** Events Resize **/ onResizerDragStart(e) { e.dataTransfer.setDragImage(ComponentManager.instance.blank.dom, 0, 0); var style = window.getComputedStyle(this.component.target); this.component.drag = { start: e, position: { x:parseInt(style.left.slice(0, -2)), y:parseInt(style.top.slice(0, -2)) }, dimension: { w: parseInt(style.width.slice(0, -2)), h: parseInt(style.height.slice(0, -2)) } }; console.log(this.component.drag); e.stopPropagation(); } onResizeBottom(e) { var h = this.component.drag.dimension.h + (ComponentManager.instance.mouse.clientY - this.component.drag.start.clientY); this.component.target.style.height = `${h}px`; e.stopPropagation(); } onResizeTop(e) { var h = this.component.drag.dimension.h - (ComponentManager.instance.mouse.clientY - this.component.drag.start.clientY); var t = Math.clamp(this.component.drag.position.y - (this.component.drag.start.clientY - ComponentManager.instance.mouse.clientY), 0, this.component.drag.position.y + this.component.drag.dimension.h); this.component.target.style.height = `${h}px`; this.component.target.style.top = `${t}px`; e.stopPropagation(); } onResizeLeft(e) { var w = this.component.drag.dimension.w - (ComponentManager.instance.mouse.clientX - this.component.drag.start.clientX); var l = Math.clamp(this.component.drag.position.x - (this.component.drag.start.clientX - ComponentManager.instance.mouse.clientX), 0, this.component.drag.position.x + this.component.drag.dimension.w); this.component.target.style.width = `${w}px`; this.component.target.style.left = `${l}px`; e.stopPropagation(); } onResizeRight(e) { var w = this.component.drag.dimension.w + (ComponentManager.instance.mouse.clientX - this.component.drag.start.clientX); this.component.target.style.width = `${w}px`; e.stopPropagation(); } }